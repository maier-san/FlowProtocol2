\chapter{Einleitung}
Die Softwareentwicklung ist ein spannender Beruf, und die KI-Entwicklungen der letzten Jahre haben ihn vermutlich mehr verändert, als alle Technologien davor, und doch ist die Grundaufgabe immer noch die gleiche, Programmcode zu schreiben, der die gestellten Anforderungen erfüllt, zu denen grundsätzlich Benutzertauglichkeit und Fehlerfreiheit gehören.
Gerade bei großen und langlebigen Softwareprodukten nimmt der Aspekt Wartbarkeit eine sehr zentrale Rolle ein, da er sowohl die Aktualität der technischen Komponenten betrifft, als auch die Fähigkeit der Entwicklungsteams, mit dem zunehmend älteren und umfangreicheren Programmcode klarzukommen. Um dies zu gewährleisten muss man permanent vorausschauend agieren, auf Modularität und eine klare Architektur achten, Best Practices dokumentieren und aktuell halten und wichtige Entscheidungen stets auf eine nachvollziehbare Grundlage stützen.

Nun kommt hinzu, dass all diese Dinge nicht nur kontinuierlich die eigentliche Arbeit begleiten, sondern dass diese Arbeit, zumindest dort, wo man sie als professionelle Softwareentwicklung bezeichnet, auch noch unvermindert effizient stattfinden soll, da man mit den eingesetzten Lohnkosten eine möglichst große Wertschöpfung erzielen möchte.

Dieses Buch beleuchtet verschiedene Themen rund um den Entwicklungsprozess und beschreibt anhand von Beispielen, wie sich Abläufe der Entwicklungstätigkeit, Entscheidungsfindung und Qualitätssicherung so formalisieren und aufbereiten lassen, dass sie fast ohne Lernphase angewendet werden können und auf diese Weise einen definierten Standard sicherstellen. Im Mittelpunkt steht dabei die auch schon titelgebende Software \FPZ, mit der sich sehr einfach Skripte in einem Netzwerk bereitstellen lassen, die dann direkt über einen Browser ausgeführt werden können. Entscheidend ist hierbei, diese Skripte nicht als technischen Programmcode zu sehen, der von einer Maschine ausgeführt wird, sondern als hinterlegtes Systemwissen, dass in der Interaktion aus Fragen und Antworten im Zusammenspiel mit dem Anwender direkt angewendet wird.

Aus diesem Grund sind die Beispiele auch vorwiegend auf die Inhalte bezogen und und nicht auf die Implementierung. Sie sollen zeigen, wie solche Fragen und die dazugehörenden Antwortmöglichkeiten aussehen können. Die Umsetzung in Form von \FPZb-Skripten setzt meist nur die Kenntnis weniger Skriptbefehle voraus, die in den jeweiligen Abschnitten kurz vermittelt wird. Eine vollständige Einführung in die \FPZb-Skriptsprache, ebenfalls in Verbindung mit dem Thema Softwareentwicklung, wird mit \cite{maier} gegeben.

Dieses Buch sollte grundsätzlich für jeden interessant sein, der sich beruflich oder privat mit dem Thema Softwareentwicklung auseinandersetzt und ganz besonders für diejenigen, die Teil eines Entwicklungsteams sind, und die sich deshalb mit den verschiedenen, im Unternehmenskontext relevanten Aspekten dieses Themas auseinandersetzen müssen oder sogar wollen. Egal, ob man am Ende \FPZ selber einsetzen möchte oder nicht, die beschriebenen Herausforderungen sind auch unabhängig davon interessant und viele wird man wiedererkennen und dabei dann doch die eine oder andere Idee mitnehmen.

\section{FlowProtocol 2}
\FPZ\ ist die zweite Version einer von mir geschriebenen .Net-Anwendung, deren Vorgängerversion schon im Winter 2021/22 begonnen wurde. Die Grundidee hinter der Anwendung bestand darin, eine Checkliste für einen allgemeinen Anwendungsfall durch mehrere und auch verschachtelte Fragestellungen präzise auf die aktuell vorliegende Situation zuzuschneiden, so dass das Ergebnis ausschließlich relevante Punkte enthält und diese mit einem hohen Detailgrad abdecken kann. Der Bedarf dafür entstand durch ein sehr großes Transformationsprojekt, bei dem eine über viele Jahre gewachsene Software in einer zukunftssicheren und besser skalierbaren Technologie neu aufgebaut werden musste. Nach Aufbau des benötigten Frameworks gibg es daran, die vielen einzelnen Programmbereiche zu portieren, wofür jeweils das Arragement und die Konfiguration der im Zielframework verfügbaren Grundbausteine möglichst präzise beschrieben werden musste, samt aller Abhängigkeiten und Sonderfälle.

Die Vorgehensweise, die gewünschten Komponenten und ihr Verhalten einfach per Mausklick auszuwählen war selbst gegenüber der zuvor eingesetzt Diktiersoftware um ein Vielfaches effizienter, aber der Hauptvorteil bestand in der Benutzerführung, die einen zielsicher mit allen zu klärenden Fragen konfrontierte und dabei ganz automatisch die Abhängigkeiten berücksichtigte, die durch die Komponenten vorgegeben waren. Das berühmte weiße Blatt Papier, das nur mit dem notwendigen Zielwissen und viel Erfahrung gefüllt werden konnte, wurde ersetzt durch die Beantwortung einer Reihe von Fragen mit einer vorgegebenen Auswahl an möglichen Antworten. Das Finden der \glqq richtigen\grqq\ Antworten war kein Problem, da im Normalfall ja nur die vorliegende Situation, sprich das Systemwissen abgefragt wurde, mit der man sowieso gut vertraut war. 

Stück für Stück wurde ein System aus Regeln und Konventionen geschaffen, bei dem die Form der Umsetzung in weiten Teilen nur noch aus den objektiven Aspekten der Anforderungen ergab und ohne personell aufwändige Individualentscheidungen klar und einheitlich festgelegt werden konnte. Wo möglich wurden diese Regeln direkt in den Skripten verankert und dort die ausschlaggebenden Anforderungen abgefragt. Dort, wo es doch Entscheidungungen zu treffen galt, wurden die im Kontext dieser Fragestellung relevanten Konventionen aufgelistet, so dass auch hier die Einheitlichkeit im Vordergrund stand und der Entscheider nur noch die Aufgabe hatte, die Situation richtig zu bewerten.

Nach vielen Erweiterungen und der komplett neu aufgebauten Version \FPZ\ enthält die Skriptsprache nun alles, um Informationen programmtechnisch abzufragen und daraus Ausgaben zu erzeugen, doch die Kernidee ist nach wie vor die gleiche: Bilde Wissen, das so klar ist, um damit Entscheidungen zu treffen und bilde diese Entscheidungsprozesse in Form von Skripten ab, die von jedem verwendet werden können. Aktualisiere dieses Wissen immer dann, wenn es sich verändert oder etwas hinzukommt und vermeide es, zu umfangreiches Wissen in den Köpfen der Mitarbeiter zu verwalten. Der Wert eines Skriptes bemisst sich nicht an der Menge der Berechnungen, die es einem abnimmt, sondern and der Menge des Wissens, das man sich damit nicht aneignen muss, um die entsprechende Aufgabe korrekt zu bearbieten.




%Die Skriptbeispiele sind auch in
%\begin{quote}
%\texttt{https://github.com/maier-san/FlowProtocol2}
%\end{quote}
%enthalten.

