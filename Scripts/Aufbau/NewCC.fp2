~SetInputDescription Hilft bei der Erstellung eines neuen FlowProtocol-2-Befehls.
~Input cmdline: Gib das Muster für die gewünschte Befehlszeile ein.
~AddHelpLine Beginnend mit ~<Befehlsname> und Einbindung aller Argumente in runden Klammern.
~AddHelpLine Verwende folgende Präfixe, um den Typ der Argumente anzugeben: v = Name einer Variable, t = Funktionsname (ohne Variablenauflösung), 
	__ d = Datumsangabe (inklusive Variablen), i = ganzzahliger Wert (inklusive Variablen), f = Dezimalwert (inklusive Variablen), x = beliebiger Text,
	__ s = beliebiger Text ohne Strichpunkt, k = Key (inklusive Variablen)
~AddHelpLine Verwendet eckige Klammern um einzelne optionale Blöcke zu kennzeichnen.
~AddHelpLine Variablennamen, die "File" oder "Path" enthalten werden, werden um Pfadtrennzeichenersetzungen ergänzt.
~AddHelpLine Beispiel: ~Tralala (vVarName) = (dDatum)[; Range=(iVon)..(iBis)][; BaseKey=(vBaseKey)]
@Eingabe >>|$cmdline
?NCD: Soll in der Doku auf ein anderes Codebeispiel verwiesen werden?
#j: Ja
	~Input RefCB: Auf welches Codebeispiel soll verwiesen werden?
	~Set MitCB=ja
#n: Nein
	~Set MitCB=nein
~Execute

// Name des Befehls notieren
~RegExMatch regcmd=$cmdline|~([A-Za-z0-9]+)( ?)(.*)
~Set CommandName=$regcmd(1)
~RegExReplace CmdWS=$regcmd(2)|\s+->\s+
~Set Args=$regcmd(3)

// *** Reguläre Ausdrücke in Abhängigkeit bestimmter Variablentypen
// Variablenname
~Set reporeg(v)=[A-Za-z0-9\$\(\)]+
// Funktionsname (ohne Variablenauflösung)
~Set reporeg(t)=[A-Za-z0-9]+
// Datumsangabe (inklusive Variablen)
~Set reporeg(d)=[A-Za-z0-9\$\(\)\.\-\/: ]+
// ganzzahliger Wert (inklusive Variablen)
~Set reporeg(i)=-?[A-Za-z0-9\$\(\)]+
// Dezimalwert (inklusive Variablen)
~Set reporeg(f)=-?[A-Za-z0-9\$\(\)\.\,]+
// beliebiger Text
~Set reporeg(x)=.*
// beliebiger Text ohne Strichpunkt
~Set reporeg(s)=[^;]*
// Key
~Set reporeg(k)=[A-Za-z0-9\$\(\)]*'?
// Alle Typen
~Set AllTypes=v t d i f x s k
~Replace AllTypeBlock=$AllTypes|$Chr(32)->
~Split AllTypeList=$AllTypes|$Chr(32)

// *** Ausdruck parsen
~Set ParserExpression=^~$CommandName$CmdWS
~Set ExceptionVarList=
~Set Syntaxpassed=
~Set ArgsWS=$Args
// Leerzeichen durch $Chr(149) ersetzen, damit sie beim Splitten nicht weggetrimmt werden
~RegExReplace ArgsWS=$ArgsWS|\s+->$Chr(149)
// Zusätzliche Leerzeichen vor und nach = und zwischen [ und ;
~Replace ArgsWS=$ArgsWS|=->$Chr(149)=$Chr(149)
~Replace ArgsWS=$ArgsWS|[;->[$Chr(149);
~Replace ArgsWS=$ArgsWS|$Chr(149)$Chr(149)->$Chr(149)
~Split ArgList=$ArgsWS|(
~Set argidx=0
~Split MaskSignList=\ $Chr(124) . ? * + - ^|$Chr(32)
~ForEach token in ArgList
	~RegExMatch regvar=$token|([$AllTypeBlock])([^)]+)\)(.*)
	~If $regvar(0)
		~AddTo argidx+=1
		~Set argindex($argidx)=$argidx
		~Set argtype($argidx)=$regvar(1)
		~CamelCase argname($argidx)=$regvar(2)
		~Replace argtext($argidx)=$regvar(2)|$Chr(149)->$Chr(32)
		~Replace argsyntax($argidx)=$regvar(3)|$Chr(149)->$Chr(32)
		~Set pexp=$regvar(3)
		~Set ParserExpression=$ParserExpression(##$argtype($argidx)##)
		~Set ExceptionVarList=$ExceptionVarList expanded$argname($argidx)='{expanded$argname($argidx)}'
		~Split CountEKA=$Syntaxpassed|[			
		~CalculateExpression groupindex($argidx) = $argidx + $CountEKA(0) - 1
		~Set IsOptional($argidx)=nein
		~If $CountEKA(0)>1
			~Set IsOptional($argidx)=ja
		~Set Syntaxpassed=$Syntaxpassed$regvar(3)
	~Else
		~Set pexp=$token
	// Zeichen maskieren
	~ForEach symbol in MaskSignList
		~Replace pexp=$pexp|$symbol->\$symbol
	~Loop
	~Set ParserExpression=$ParserExpression$pexp
~Loop

// *** Regulären Ausdruck für den Parser zusammensetzen
~Replace ParserExpression=$ParserExpression|[->(
~Replace ParserExpression=$ParserExpression|]->)?
~ForEach type in AllTypeList
	~Replace ParserExpression=$ParserExpression|##$type##->$reporeg($type)
~Loop
~Replace ParserExpression=$ParserExpression|$Chr(149)->\s*

// *** Flags für besondere Variablen setzen
~ForEach idx in argindex	
	~If $argname($idx)==BaseKey
		~Set BKeyArgument=ja
~Loop

// *** Implementierungsanleitung ausgeben
@Implementierung >> Klasse erstellen (Menüpunkt "New File" im Ordner Commands)
	>|Cmd$CommandName.cs
@Implementierung >> Code einfügen:
	>|namespace FlowProtocol2.Commands
	>|{
	>|    using System.Globalization;
	>|    using System.Text.RegularExpressions;
	>|    using FlowProtocol2.Core;
	>|
	>|    /// <summary>
	>|    /// Implementiert den $CommandName-Befehl	
	>|    /// </summary>
	>|    /// <remarks>
	>|    /// Erstellt mit NewCC.fp2, Eingabe: $cmdline
	>|    /// </remarks>
	>|    public class Cmd$CommandName : CmdBaseCommand
	>|    {
~ForEach idx in argindex
	>|        public string $argname($idx) { get; set; }
~Loop	
	>|
	>|        public static CommandParser GetComandParser()
	>|        {
	>|            return new CommandParser(@"$ParserExpression",
	>|                                     (rc, m) => Create$CommandNameCommand(rc, m));
	>|        }
	>|
	>|        private static CmdBaseCommand Create$CommandNameCommand(ReadContext rc, Match m)
	>|        {
	>|            Cmd$CommandName cmd = new Cmd$CommandName(rc);
~ForEach idx in argindex
	>|            cmd.$argname($idx) = m.Groups[$groupindex($idx)].Value.Trim();
~Loop
	>|            return cmd;
	>|        }
	>|
	>|        public Cmd$CommandName(ReadContext readcontext) : base(readcontext)
	>|        {
~ForEach idx in argindex
	>|            $argname($idx) = string.Empty;
~Loop
	>|        }
	>|
	>|        public override CmdBaseCommand? Run(RunContext rc)
	>|        {		
~ForEach idx in argindex
	~If $argname($idx)~File || $argname($idx)~Path
		>|            string expanded$argname($idx) = ReplaceVars(rc, $argname($idx)).Replace('|', Path.DirectorySeparatorChar);
		~Set PfadArgument=ja
	~Else
		>|            string expanded$argname($idx) = ReplaceVars(rc, $argname($idx));
~Loop
	>|            try
	>|            {
~Set UseVarList=...verwende folgende Variablen:
~ForEach idx in argindex
	~If $IsOptional($idx)==ja
		>|                if (string.IsNullOrWhiteSpace(expanded$argname($idx)))
		>|                {
		>|                    // Optionales Argument mit Variable $argname($idx) wurde weggelassen
		>|                    expanded$argname($idx) = "ToDo";
		>|                }		
	~If $argtype($idx)==d
		>|                bool bOK$argname($idx) = DateTime.TryParseExact(expanded$argname($idx), "yyyy-MM-dd HH:mm:ss", rc.Culture, DateTimeStyles.None, out DateTime result$argname($idx));
		>|                if (!bOK$argname($idx))
		>|                {
		>|                    rc.SetError(ReadContext, "Falsches Datumsformat",
		>|                        $"Der Ausdruck '{expanded$argname($idx)}' kann nicht als Datum im Format 'yyyy-MM-dd HH:mm:ss' interpretiert werden. Die Ausführung wird abgebrochen.");
		>|                    return null;
		>|                }
		~Set UseVarList=$UseVarList, result$argname($idx)
		~Set ExceptText(d)=Falsches Datumsformat: Der Ausdruck ... kann nicht als Datum im Format 'yyyy-MM-dd HH:mm:ss' interpretiert werden. Die Ausführung wird abgebrochen.
	~ElseIf $argtype($idx)==i
		>|                bool bOK$argname($idx) = Int32.TryParse(expanded$argname($idx), out int result$argname($idx));
		>|                if (!bOK$argname($idx))
		>|                {
		>|                    rc.SetError(ReadContext, "Ungültiger numerischer Ausdruck",
		>|                        $"Der Ausdruck '{expanded$argname($idx)}' kann nicht als ganze Zahl interpretiert werden. Die Ausführung wird abgebrochen.");
		>|                    return null;
		>|                }
		~Set UseVarList=$UseVarList, result$argname($idx)
		~Set ExceptText(i)=Ungültiger numerischer Ausdruck: Der Ausdruck ... kann nicht als ganze Zahl interpretiert werden. Die Ausführung wird abgebrochen.
	~ElseIf $argtype($idx)==f
		>|                bool bOK$argname($idx) = double.TryParse(expanded$argname($idx), out double result$argname($idx));
		>|                if (!bOK$argname($idx))
		>|                {
		>|                    rc.SetError(ReadContext, "Ungültiger numerischer Ausdruck",
		>|                            $"Der Ausdruck '{expanded$argname($idx)}' kann nicht als Gleitkommazahl interpretiert werden. Die Ausführung wird abgebrochen.");
		>|                    return null;
		>|                }
		~Set UseVarList=$UseVarList, result$argname($idx)
		~Set ExceptText(f)=Ungültiger numerischer Ausdruck: Der Ausdruck ... kann nicht als Gleitkommazahl interpretiert werden. Die Ausführung wird abgebrochen.
	~Else
		~Set UseVarList=$UseVarList, expanded$argname($idx)
~Loop
	>|                // ToDo: Befehl hier implementieren
	~Replace UseVarList=$UseVarList|:,->:
	>|                // $UseVarList
	~If $argtype(1)==v
		>|	
		>|                // Ergebnis der Variablen zuweisen
		>|                rc.InternalVars[expanded$argname(1)] = 'ToDo';
	~If $BKeyArgument==ja		
		>|
		>|                // BaseKey-Stack aktualisieren und nächsten Befehl festlegen
		>|                if (NextCommand != null) rc.ReturnStack.Push(new EntryPoint(NextCommand, rc.BaseKey));
		>|                rc.BaseKey = expandedBaseKey;
		>|                //ToDo return ???.StartCommand;			
	>|            }
	>|            catch (Exception ex)
	>|            {
	>|                rc.SetError(ReadContext, "Verarbeitungsfehler",
	>|                    $"Beim Ausführen des Skriptes ist ein Fehler aufgetreten '{ex.Message}'. Die Ausführung wird abgebrochen."
	>|                    + $"Variablenwerte:$ExceptionVarList");
	>|                return null;
	>|            }
	>|            return NextCommand;
	>|        }
	>|    }
	>|}
@Implementierung >> Regulären Ausdruck in Methode 
	~AddCode  GetComandParser()
	~AddText  anpassen, falls nötig.
	>* Am besten mehrere Beispiele mit 
	~AddLink https://regex101.com | regex101.com
	~AddText  ausprobieren.
	>.|$ParserExpression
@Implementierung >> Run-Methode ausimplementieren
	~ForEach idx in argindex
		~If $IsOptional($idx)==ja
			># Standardwert/ -verhalten für optionales Argument festlegen bei
			~AddCode  // Optionales Argument mit Variable expanded$argname($idx) wurde weggelassen
	~Loop
	~If $PfadArgument==ja
		># Pfadtrennzeichenersetzung für Pfadvariablen prüfen
	~If $BKeyArgument==ja
		># BaseKey-Stack-Aktualisierung prüfen und nächsten Befehl festlegen bei
			~AddCode  // BaseKey-Stack aktualisieren und nächsten Befehl festlegen
	># Run-Methode ausimplementieren bei 
		~AddCode  // ToDo: Befehl hier implementieren
	~If $argtype(1)==v
		># Variablenzuweisung vervollständigen oder entfernen bei
			~AddCode  // Ergebnis der Variablen zuweisen
@Implementierung >> Allgemeine Regeln überprüfen
	>* Regel 1: Die in
	~AddCode  Create$CommandNameCommand
	~AddText  eingelesenen Eigenschaften bleiben unverändert, so dass der Befehl wiederholt ausgeführt werden kann.
	>* Regel 2: Die Variablenersetzung erfolgt so tief wie möglich, so dass die Syntax unabhängig von den Variablenwerten ist.
	>* Regel 3: Die Verkettung der Befehle mit
	~AddCode  NextCommand
	~AddText  und
	~AddCode  PreviousCommand
	~AddText  bleibt unverändert.
	>* Regel 4: Intern über mehrere Befehlsaufrufe gespeicherte Zustänge sollten immer in Abhängigkeit der
	~AddCode  BaseKey
	~AddText -Variaben als Dictionary verwaltet werden, so dass auch iterative Aufrufe möglich sind.
@Implementierung >> Befehl in SkriptParser hinzufügen
	>* in Datei
	~AddCode  ScriptParser.cs
	>* in Methode
	~AddCode  private void LoadCommands()
	>.|CmdParser.Add(Cmd$CommandName.GetComandParser());
@Implementierung >> Versionsnummer hochzählen
	>* in Datei 
	~AddCode  .\FlowProtocol2\Pages\Shared\_Layout.cshtml
	>* Hintere Nummer in Zeile 43 hochzählen. Suche nach
	>.|&copy; 2023 MSan, Version

@Dokumentation >> Neue Flow-DokuDatei anlegen
	>* Neue Datei in Notepad++ erstellen
@Dokumentation >> Code einfügen
	>|~SetTitle $CommandName-Befehl
	>|@Beschreibung >>_ Der Befehl 
	>|~AddCode  ~$CommandName
	>|~AddText  ...
~ForEach idx in argindex
	>|~AddCode  <$argtext($idx)>
	>|~AddText  ...
~Loop	
	>|@Ausnahmen >>* Verarbeitungsfehler: Beim Ausführen des Skriptes ist ein Fehler aufgetreten ... . Die Ausführung wird abgebrochen.	
	~Split ExceptionTypelist=d,f,i|,
	~ForEach type in ExceptionTypelist
		~If ?$ExceptText($type)
			>|    >>* $ExceptText($type)
	~Loop
~If $MitCB==ja
	>|@Codebeispiel >>_ siehe 
	>|~Replace $RefCBURL = $Chr(36)BaseURL|$CommandName->$RefCB
	>|~AddLink $Chr(36)$RefCBURL | ~$RefCB
~Else
	>|@Codebeispiel >>_ Das nachfolgende Beispiel ...
	>|>>|...
	>|@Ausgabe >> Testausgabe
@Dokumentation >> Vervollständigen
	># Beschreibung
	># Ausnahmen
	># Beispielcode
	># Beispielbeschreibung
@Dokumentation >> Fertiges Beispiel in Codeblock übernehmen
@Dokumentation >> Speichern unter
	>|D:\Entwicklung\MSanGitDev\FlowProtocol2\Scripts\FP2-Tutorial\$CommandName.fp2
@Buch erweitern >> FP2Inhalt.tex öffnen
	>|D:\Entwicklung\MSanGitDev\FlowProtocol2\Doc\FP2Inhalt.tex
@Buch erweitern >> Zu Abschnitt Befehle gehen
		>|\subsection{Befehle}\label{Befehle}
@Buch erweitern >> An der für 
	~AddCode  ~$CommandName
	~AddText  alphabetisch richtigen Stelle einfügen:
		>|\item[\fcmd{$CommandName}]
		~ForEach idx in argindex
			~Trim syntws=$argsyntax($idx)
			~Set verbmask=$Chr(124)
			~If $syntws~$verbmask
				~Set verbmask=$Chr(61)
			~Replace syntex=$Chr(32)\verb$verbmask$syntws$verbmask|$Chr(32)\verb$verbmask$verbmask->
			~AddText  \synvar{$argtext($idx)}$syntex
		~Loop
		~AddText \\
		>|Fügt usw.\\
		>|%Siehe Abschnitt~\ref{Hilfezeilen}, verwendet in Beispiel~\ref{BspHilfezeilen}.			
@Buch erweitern >> Beschreibung übernehmen.
@Buch erweitern >> Verweise anpassen oder entfernen.